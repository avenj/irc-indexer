#!perl
use 5.12.1;
use strict;
use warnings;

use POE;

use IRC::Indexer;
use IRC::Indexer::Conf;
use IRC::Indexer::Logger;
use IRC::Indexer::Output::JSON;

use URI;

use POEx::HTTP::Server;

use Storable qw/dclone/;

my $opts = {
  help => sub {
  
  },
  
  version => sub {
  
  },
  
  
};
use Getopt::Long;
GetOptions( $opts,
  qw/
    help 
    version
    
    port:8700
    
  /,
);

my $obj = {
  Log    => undef,
  Cfg    => undef,
  HTTP   => undef,
  Multi  => undef,
};

my $state = { 
  networks => {
    ## hash keyed on network name
    ## each network is a hash keyed on server name
    ## containing Info::Server objects
  },

  timers => {},
  stats  => {
    StartedAt => time,
    RunCount  => 0,
  },
};

my $cfg = { 
  ## build out of network dirs:
  NetworkList => [],
  
  Interval => 15,
  Timeout  => 90,
  
  LogFile  => undef,
  LogHTTP  => undef,
  LogIRC   => undef,
};

sub get_cfg {
  ## set up $cfg and logging
}

sub poco_cfg_httpd {
  $state->{handlers} = [
    '^/$' => 'poe:indexerhttp/h_root',

    '^/stats'   => 'poe:indexerhttp/h_stats', 
    '^/network' => 'poe:indexerhttp/h_network',

    '' => 'poe:indexerhttp/h_error_404',
  ];
  
  $state->{htevents} = [ map { 'h_'.$_ } qw/
     root error_404
     stats
     server network
  / ];


  POEx::HTTP::Server->spawn(
    inet => {
      LocalPort => $opts->{port},
    },
    
    handlers => dclone($state->{handlers}),
  );
  
  return 1
}

sub poco_init_session {
  ## create 'indexerhttp' session
  POE::Session->create(
    package_states => [
      main => [ qw/
        _start
        _stop
        _timer_chk
      / ],
    ],
  );

}

sub _timer_chk {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my $pool = $state->{timers};
}

sub _start {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  $kernel->alias_set('indexerhttp');

  ## init httpd
  my @htstates = poco_cfg_httpd();
  
  ## add states from $state->{handlers}
  $kernel->state($_, __PACKAGE__) for @{$state->{htevents}};
  
  ## FIXME init trawling
}

sub _stop {}

## HTTP states

sub h_error_404 {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];
  $resp->error(404, "Undefined action: ".$req->uri);
}

sub h_root {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];
  ## templated html root ?
  $resp->content_type('text/html');
  $resp->content("
   <html><head><title>IRC::Indexer</title></head>
   <body>
   <p>Running.</p>
   </body>
   </html>
  ");
  $resp->respond;
  $resp->done;
}

sub h_stats {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];

  $resp->done;
}

sub h_server {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp)       = @_[ARG0, ARG1];
  my ($network, $server) = @_[ARG2, ARG3];
  ## handed off by h_network
  
  $resp->respond;
  $resp->done;
}

sub h_network {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];
  ## handler for /network/...

  my $uri = URI->new($req->uri);
  my @chunks = $uri->path_segments;
  splice @chunks, 0, 2;

  ## if there's no network specified, 404
  my ($network) = @chunks;
  unless ($network) {
    $kernel->yield( h_error_404 => $req, $resp );
    return
  }
  
  ## if this is a /network/<net>/server, hand it off
  if ($chunks[1] && $chunks[1] eq "server") {
    my $server = $chunks[2];
    $kernel->yield( h_error_404 => $req, $resp )
      unless $server;
    $kernel->yield( h_server => $req, $resp, $network, $server );
    return
  }
  
  ## else, this should be a request for netinfo hash
  ## FIXME handler for this
  ## FIXME 404 if we don't know this network
  ## FIXME set up JSON content 

  $resp->respond;
  $resp->done;
}

poco_init_session();
POE::Kernel->run;

## FIXME
##  get a specified conf and set up a logger
##  run Multi trawlers at intervals
##  serve JSON (from memory? berkdb as on-disk cache?)
__END__

=pod


=cut
