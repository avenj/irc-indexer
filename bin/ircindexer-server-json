#!perl
use 5.12.1;
use strict;
use warnings;

use POE;

use IRC::Indexer;
use IRC::Indexer::Conf;
use IRC::Indexer::Logger;
use IRC::Indexer::Output::JSON;

use URI;

use POEx::HTTP::Server;

use Scalar::Util qw/blessed/;
use Storable qw/dclone/;

my $opts = {
  help => sub {
  
  },
  
  version => sub {
  
  },
  
  
};
use Getopt::Long;
GetOptions( $opts,
  qw/
    help 
    version
    
    port:8700
    
    config=s
    
    loglevel=s
    
  /,
);

my $json = { };

my $obj = {
  Log    => undef,
  Cfg    => undef,
  
  ##  network -> server -> $obj
  Trawlers => {},
};

my $state = { 
  timers => { trawlers => {} },
  stats  => {
    StartedAt => time,
    RunCount  => 0,
  },
};

my $cfg = { 
  Networks => {},
  Interval => 15,
  Timeout  => 90,
  
  LogFile  => undef,
  LogLevel => undef,
  LogHTTP  => undef,
  LogIRC   => undef,
};

sub get_cfg {
  ## set up $cfg and logging
  
  die "No --config specified.\n" unless $opts->{config};
  
  die "Specified conf nonexistant: $opts->{config}"
    unless -e $opts->{config};

  die "Specified conf not readable: $opts->{config}"
    unless -r $opts->{config};
  
  my $conf = IRC::Indexer::Conf->new;
  $obj->{Cfg} = $conf;
  my $cfhash;
  
  {
    local $@;
    eval { $cfhash = $conf->parse_conf($opts->{config}) };
    die "Could not parse conf: $@" if $@;
  }
  
  unless ($cfhash->{NetworkDir}) {
    die "Configuration directive missing: NetworkDir\n"
  }
    
  for my $thisopt (keys %$cfg) {
    $cfg->{$thisopt} = $cfhash->{$thisopt};
  }
  
  if ($cfg->{LogFile}) {
    my $loglevel = $opts->{loglevel} || $cfg->{LogLevel} || 'info' ;
    my $handler = IRC::Indexer::Logger->new(
      LogFile  => $cfg->{LogFile},
      LogLevel => $loglevel,
    );
    $obj->{Log} = $handler->logger;
  }
  
  my $nethash = $conf->parse_nets($cfhash->{NetworkDir});
  $cfg->{Networks} = $nethash;
}

sub log_to {
  ## log_to('http', 'warn', ...)
  ## log_to('irc', 'info', ...)
  ## null-op if there's no logger present
  my ($type, $level, @lines) = @_;
  return unless @lines;
  my $log = $obj->{Log};
  return unless blessed $log;
  
  given (lc $type) {
  
    when ("http") {
      return unless $cfg->{LogHTTP};
      $log->$level("$type ", @lines);
    }
    
    when ("irc") {
      return unless $cfg->{LogIRC};
      $log->$level("$type ", @lines);
    }
    
    default {
      ## anything else goes right to the log:
      $log->$level("$type ", @lines);
    }
  
  }
}

sub poco_cfg_httpd {
  $state->{handlers} = [
    '^/$' => 'poe:indexerhttp/h_root',

    '^/stats'   => 'poe:indexerhttp/h_stats', 
    '^/network' => 'poe:indexerhttp/h_network',

    '' => 'poe:indexerhttp/h_error_404',
  ];
  
  $state->{htevents} = [ map { 'h_'.$_ } qw/
     root error_404
     stats
     server network
  / ];


  POEx::HTTP::Server->spawn(
    inet => {
      LocalPort => $opts->{port},
    },
    
    handlers => dclone($state->{handlers}),
  );
  
  log_to('http', 'info', 'HTTP configured');
  
  return 1
}

sub poco_init_session {
  ## create 'indexerhttp' session
  POE::Session->create(
    package_states => [
      main => [ qw/
        _start
        _stop
        _timer_chk
        _trawler_chk
      / ],
    ],
  );

  log_to('session', 'debug', 'Session initialized');
}

sub _timer_chk {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my $pool = $state->{timers};
  
  my @trawlers;

  NETWORK: for my $network (keys %{$pool->{trawlers}}) {
    my $this_net = $pool->{trawlers}->{$network};
    SERVER: for my $server (keys %$this_net) {
      my $this_server = $this_net->{$server};

      ## FIXME configurable trawl interval
      next SERVER unless time - $this_server->{LastRun} > 300;

      my $this_trawler = $state->{Trawlers}->{$network}->{$server};
      next SERVER unless blessed $this_trawler;

      push(@trawlers, [ $this_trawler, $network, $server ]);
      
      $this_server->{LastRun} = time;
    }
  }
  
  $kernel->yield('_trawler_chk', @trawlers)
    unless $heap->{TRAWLCHK_RUNNING};

  $kernel->alarm('_timer_chk' => time + 3);
}

sub _trawler_chk {
  ## event _trawler_chk(@trawler_objs ...)
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my (@remaining) = @_[ARG0 .. $#_];
  my $idx = 0;
  
  $heap->{TRAWLCHK_RUNNING} = 1;
  
  ## check trawlers in a loop, 10 at a time
  until (!@remaining || $idx == 10) {
    my $item = shift @remaining;
    my ($trawler, $network, $server) = @$item;
    if ($trawler->done) {
      log_to('irc', 'info', 
        "handling completed trawler: $network ($server)"
      );
      
      if (my $err = $trawler->failed) {
        log_to('irc', 'warn',
          "trawler reports failure: $network ($server): $err"
        );
        next
      }
      
      ## feed to JSONify
      my $js = IRC::Indexer::Output::JSON->new(
        Input => $trawler->dump,
      );
      
      ## save JSONified output
      $json->{$network}->{$server} = $js->dump;
      log_to('irc', 'debug',
        "Cached JSON: $network ($server)"
      );
    }
  }
  
  ## FIXME method/event to merge servers into networks
  ## ::Network can do some of this ?
  
  if (@remaining) {
    $kernel->yield('_trawler_chk', @remaining);
  } else {
    delete $heap->{TRAWLCHK_RUNNING};
  }
}

sub _start {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  $kernel->alias_set('indexerhttp');

  log_to('session', 'debug', 'Session started');

  ## init httpd
  my @htstates = poco_cfg_httpd();
  
  ## add states from $state->{handlers}
  $kernel->state($_, __PACKAGE__) for @{$state->{htevents}};
  
  NETWORK: for my $network (keys %{ $state->{Networks} }) {
    my $this_net = $state->{Networks}->{$network};
    SERVER: for my $server (keys %$this_net) {
      my $this_cf = $this_net->{$server};
      
      log_to('irc', 'debug', "New trawler: $network -> $server");
      
      my $trawler = IRC::Indexer::Trawl::Bot->new(
        Server => $server,
        Port   => $this_cf->{Port},
        Nickname => $this_cf->{Nickname},
        Timeout  => $this_cf->{Timeout},
        Interval => $this_cf->{Interval},
        BindAddr => $this_cf->{BindAddr},
        UseIPV6  => $this_cf->{UseIPV6},
      );
      
      $obj->{Trawlers}->{$network}->{$server} = $trawler;
      
      log_to('irc', 'debug', "Starting trawler for $server");
      $trawler->run;
      
      ## FIXME add to check pool
      $state->{timers}->{trawlers}->{$network}->{$server} = {
        LastRun => 0,
      };
    }
  }
  
  $kernel->alarm('_timer_chk' => time + 3);
  
  ## FIXME log number of trawlers spawned
}

sub _stop {}

## HTTP states

sub h_error_404 {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];
  
  my $uri  = URI->new( $req->uri );
  my $path = $uri->path;
  my $conn = $req->connection;
  my $addr = $conn->remote_addr;
  
  log_to('http', 'info', "$addr 404 $path");
  
  $resp->error(404, "Undefined action: ".$req->uri);
}

sub h_root {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];
  ## templated html root ?
  $resp->content_type('text/html');
  $resp->content("
   <html><head><title>IRC::Indexer</title></head>
   <body>
   <p>Running.</p>
   </body>
   </html>
  ");
  $resp->respond;

  my $conn = $req->connection;
  my $addr = $conn->remote_addr;
  log_to('http', 'info', "$addr 200 h_root");

  $resp->done;
}

sub h_stats {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];

  $resp->done;
}

sub h_server {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp)       = @_[ARG0, ARG1];
  my ($network, $server) = @_[ARG2, ARG3];
  ## handed off by h_network


  $resp->respond;

  my $conn = $req->connection;
  my $addr = $conn->remote_addr;
  log_to('http', 'info', "$addr 200 h_server $network $server");
  
  $resp->done;
}

sub h_network {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];
  ## handler for /network/...

  my $uri = URI->new($req->uri);
  my @chunks = $uri->path_segments;
  splice @chunks, 0, 2;

  ## if there's no network specified, 404
  my ($network) = @chunks;
  unless ($network) {
    $kernel->yield( h_error_404 => $req, $resp );
    return
  }
  
  ## if this is a /network/<net>/server, hand it off
  if ($chunks[1] && $chunks[1] eq "server") {
    my $server = $chunks[2];
    $kernel->yield( h_error_404 => $req, $resp )
      unless $server;
    $kernel->yield( h_server => $req, $resp, $network, $server );
    return
  }
  
  ## else, this should be a request for netinfo hash
  ## FIXME handler for this
  ## FIXME 404 if we don't know this network
  ## FIXME set up JSON content 

  $resp->respond;

  my $conn = $req->connection;
  my $addr = $conn->remote_addr;
  log_to('http', 'info', "$addr 200 h_network $network");
  $resp->done;
}

poco_init_session();
POE::Kernel->run;

__END__

=pod


=cut
