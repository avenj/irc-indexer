#!perl
use 5.12.1;
use strict;
use warnings;

## FIXME optional on-disk cache / persistency
## need:
##  methods to store and retrieve
##  methods can determine whether to use DB or not
##    store networks keyed on network name
##    store servers keyed on NETNAME%servername
use DB_File;
my %JSCache;

## Core:
use POSIX ();
use Scalar::Util qw/blessed/;
use Storable     qw/dclone/;

## POE + HTTP
use POE;
use URI;
use POEx::HTTP::Server;

## Indexer:
use IRC::Indexer;

use IRC::Indexer::Conf;
use IRC::Indexer::Logger;

use IRC::Indexer::Trawl::Bot;
use IRC::Indexer::Info::Network;

use IRC::Indexer::Output::JSON;

my $opts = {
  help => sub {
    print(
      "ircindexer-server-json\n\n",
      
      "  -v, --version\n",
      "       Display IRC::Indexer version\n\n",
      
      "  -c, --config=PATH\n",
      "       Configuration file for this server.\n\n",
      
      "  -l, --loglevel=LEVEL\n",
      "      Log verbosity, one of: debug, info, warn\n",
      "      Overrides configuration file.\n\n",
      
      "  -d, --detach\n",
      "       Run as a daemon process.\n\n",
      
      "  -i, --interval=SECS\n",
      "       Interval between trawling servers on a specific network.\n",
      "       Defaults to 600 seconds (10 minutes)\n",
    );
    exit 0
  },
  
  version => sub {
    print(
      "ircindexer-server-json (IRC::Indexer $IRC::Indexer::VERSION)\n",
      "  POEx::HTTP::Server $POEx::HTTP::Server::VERSION\n",
    );
    exit 0
  },
  
  detach => 0,

  interval => 600,
};

use Getopt::Long;
GetOptions( $opts,
  qw/
    help 
    version
    
    config=s
    
    detach!

    interval=i
    
    loglevel=s
    
    showsource
  /,
);

my $jsmemcache = { };

## These are set up here for ease of reference:

my $obj = {
  Log    => undef,
  Cfg    => undef,
  
  ##  network -> server -> $obj
  Trawlers => {},
  ## Info::Network objects per-network:
  NetInfo => {},
};

my $state = { 
  timers => { trawlers => {} },
  stats  => {
    Version => $IRC::Indexer::VERSION,
    StartedAt => time,
    
    LoopTick      => 0,
    
    TotalNetworks => 0,
    TotalServers  => 0,
    
    TrawlersExecuted => 0,
    TrawlersCreated  => 0,
    
    LastTrawl        => 0,
    
    HTTP_Responses   => 0,
  },
};

my $cfg = { 
  Networks => {},
  BindAddr   => '0.0.0.0',
  ServerPort => 8700,
  CacheDB  => undef,
  
  LogFile  => undef,
  LogLevel => undef,
  LogHTTP  => 1,
  LogIRC   => 1,
};

sub get_cfg {
  ## set up $cfg and logging
  
  ## FIXME catch sighup and call get_cfg again?
  
  die "No --config specified.\n" unless $opts->{config};
  
  die "Specified conf nonexistant: $opts->{config}"
    unless -e $opts->{config};

  die "Specified conf not readable: $opts->{config}"
    unless -r $opts->{config};

  ## Try to set up primary conf: 
  my $cfpath = $opts->{config};
  my $conf = IRC::Indexer::Conf->new;
  $obj->{Cfg} = $conf;
  my $cfhash;
  
  {
    local $@;
    eval { $cfhash = $conf->parse_conf($cfpath) };
    die "Could not parse conf: $@" if $@;
  }
  
  unless ($cfhash->{NetworkDir}) {
    die "Configuration directive missing: NetworkDir\n"
  }
    
  for my $thisopt (keys %$cfg) {
    $cfg->{$thisopt} = $cfhash->{$thisopt};
  }

  ## Set up logging:
  my $loglevel = $opts->{loglevel} || $cfg->{LogLevel} || 'info' ;
    
  if ($cfg->{LogFile}) {
    my $handler = IRC::Indexer::Logger->new(
      LogFile  => $cfg->{LogFile},
      LogLevel => $loglevel,
    );
    $obj->{Log} = $handler->logger;
  }
  
  unless ($opts->{detach}) {
    unless (blessed $obj->{Log}) {
      my $handler = IRC::Indexer::Logger->new(
        DevNull => 1,
      );
      $obj->{Log} = $handler->logger;
    }
    $obj->{Log}->add(
      screen => {
          log_to   => "STDOUT",
          maxlevel => $loglevel || 'info',
          timeformat     => "%Y/%m/%d %H:%M:%S",
          message_layout => "[%T] %L %m",
      },
    );

  }
  
  $cfg->{ServerPort} //= 8700;
  
  if ($cfg->{CacheDB}) {
    tie %JSCache, "DB_File", $cfg->{CacheDB},
      O_CREAT|O_RDWR, 0644, $DB_HASH
      or die "Could not tie DB: $cfg->{CacheDB}: $!" ;    
    %JSCache = ();
  }

  ## Read server specifications:  
  my $nethash = $conf->parse_nets($cfhash->{NetworkDir});
  $cfg->{Networks} = $nethash;
}

sub log_to {
  ## log_to('http', 'warn', ...)
  ## log_to('irc', 'info', ...)
  ## null-op if there's no logger present
  my ($type, $level, @lines) = @_;
  return unless @lines;
  my $log = $obj->{Log};
  return unless blessed $log;
  
  given (lc $type) {
  
    when ("http") {
      return unless $cfg->{LogHTTP};
      $log->$level("$type ", @lines);
    }
    
    when ("irc") {
      return unless $cfg->{LogIRC};
      $log->$level("$type ", @lines);
    }
    
    default {
      ## anything else goes right to the log:
      $log->$level("$type ", @lines);
    }
  
  }
}

sub poco_cfg_httpd {
  
  $state->{htevents} = [ map { 'h_'.$_ } qw/
     error_404
     src
     stats
     list
     server 
     servlist
     network
     netlist
  / ];
  push(@{$state->{htevents}}, 'post_request');


  POEx::HTTP::Server->spawn(
    inet => {
      LocalAddr => $cfg->{BindAddr},
      LocalPort => $cfg->{ServerPort},
    },
    
    handlers => [
      '^/$'       => 'poe:indexerhttp/h_stats',
      '^/stats'   => 'poe:indexerhttp/h_stats',
       
      '^/list'    => 'poe:indexerhttp/h_list',
       
      '^/network' => 'poe:indexerhttp/h_network',
      '^/netlist' => 'poe:indexerhttp/h_netlist',
      
      '^/src'     => 'poe:indexerhttp/h_src',
      
      '' => 'poe:indexerhttp/h_error_404',
      
      'post_request' => 'poe:indexerhttp/post_request',
    ],
  );
  
  log_to('http', 'info', 'HTTP configured');
  
  return 1
}

sub poco_init_session {
  ## create 'indexerhttp' session
  POE::Session->create(
    package_states => [
      main => [ qw/
        _start
        _stop
        _timer_chk
        _trawler_run
        _trawler_process
        
        _cache_json
        
        _sig_int
      / ],
    ],
  );

  log_to('session', 'debug', 'Session initialized');
}

sub _trawler_process {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($network, $trawler) = @_[ARG0, ARG1];

  ## passed trawler objects marked as done

  unless (blessed $trawler) {
    log_to('irc', 'warn', 
      "Cannot _trawler_process unblessed trawler for $network"
    );
  }

  my $server = $trawler->info->connectedto;

  log_to('irc', 'info', 
    "Completed trawler: $network ($server)"
  );
  
  if (my $err = $trawler->failed) {
    log_to('irc', 'warn',
      "Trawler reports failure: $network ($server): $err"
    );
    next
  }
  
  ## sort ListChans:
  $trawler->info->channels;

  ## feed to JSONify
  my $s_js = IRC::Indexer::Output::JSON->new(
    Input => $trawler->dump,
  );

  ## create an Info::Network if we don't have one
  $obj->{NetInfo}->{$network} = IRC::Indexer::Info::Network->new()
    unless blessed $obj->{NetInfo}->{$network};
  
  ## feed it this server's Info object:
  $obj->{NetInfo}->{$network}->add_server($trawler->info);

  my $ref = $obj->{NetInfo}->{$network}->dump;
  my $n_js = IRC::Indexer::Output::JSON->new(
    Input => $ref,
  );

  $kernel->yield( '_cache_json',
    $network, $server, $s_js, $n_js
  );

  ## Replace this finished trawler
  my $this_trawler_cf = $cfg->{Networks}->{$network}->{$server};
  unless (defined $this_trawler_cf) {
    log_to('irc', 'warn', 
      "Cannot readd trawler: missing conf: $network: $server"
    );
    return
  }
  my %trawlopts = %$this_trawler_cf;
  my $newtrawl = create_trawler(Server => $server, %trawlopts);

  ## Push the replacement back to $obj->{Trawlers}->{$network}
  push(@{ $obj->{Trawlers}->{$network} }, $newtrawl);
  log_to('irc', 'info', "Spawned fresh trawler: $network: $server");
  
  ## If this is the only trawler, we can reschedule it now:
  unless (@{ $obj->{Trawlers}->{$network} } > 1) {
    my $next_run_at  = time + ($opts->{interval} || 600);
    $kernel->alarm_add(
      '_trawler_run', $next_run_at, $newtrawl
    );
    log_to('irc', 'info', "Scheduling single trawler for $network");
  }
}

sub cache_json {
  my ($data, $network, $server) = @_;

  if ($server) {
    ## store a server's json

    if (tied %JSCache) {
      ## using CacheDB
      my $thiskey = $network.'%'.$server;
      $JSCache{$thiskey} = $data;
    } else {
      $jsmemcache->{Servers}->{$network}->{$server} = $data;
    }

  } else {
    ## store a network's json

    if (tied %JSCache) {
      $JSCache{$network} = $data;
    } else {
      $jsmemcache->{Networks}->{$network} = $data;
    }

  }
}

sub restore_json {
  my ($network, $server) = @_;

  if ($server) {

    if (tied %JSCache) {
      my $thiskey = $network.'%'.$server;
      return $JSCache{$thiskey}
    } else {
      return unless exists $jsmemcache->{Servers}->{$network};
      return $jsmemcache->{Servers}->{$network}->{$server}
    }

  } else {
    return $JSCache{$network} if tied %JSCache;
    return $jsmemcache->{Networks}->{$network}
  }  
}

sub _cache_json {
  my $kernel = $_[KERNEL];
  my ($network, $server, $s_obj, $n_obj) = @_[ARG0 .. $#_];  
  cache_json( $s_obj->dump, $network, $server );
  cache_json( $n_obj->dump, $network );
  log_to('irc', 'info',
    "Cached JSON: $network ($server)"
  );
}

sub _timer_chk {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my $pool = $state->{timers};

  ++$state->{stats}->{LoopTick};
  
  my @trawlers;

  NETWORK: for my $network (keys %{$pool->{trawlers}}) {
    my $this_net = $pool->{trawlers}->{$network};
    
    my $last_trawled = $this_net->{LastRun};
    unless ($last_trawled) {
      ## No trawlers have been run for this network, yet.
      ## Spin one up, set LastRun time.
      $this_net->{LastRun} = time();
      if (@{ $obj->{Trawlers}->{$network} }) {
        log_to('irc', 'info', "Running initial trawler for $network");
        $kernel->yield( '_trawler_run', 
          $obj->{Trawlers}->{$network}->[0]
        );
        next NETWORK
      } else {
        log_to('irc', 'debug', "No trawlers to check for $network");
        next NETWORK
      }
    }
    
    unless (@{ $obj->{Trawlers}->{$network} }) {
      log_to('irc', 'info', "No trawlers to check for $network");
    }
    
    my @pending;
    my $idx = 0;
    TRAWLER: for my $trawler (@{ $obj->{Trawlers}->{$network} }) {
      if ($trawler->done) {
        ## Have a finished trawler.

        ## Splice this trawler out of this network's array:
        splice @{ $obj->{Trawlers}->{$network} }, $idx, 1;
        
        ## It'll be handled by _trawler_process:
        $kernel->yield( '_trawler_process', $network, $trawler );

        ## Schedule the next one for this net to run in ten minutes,
        ## if we have one.
        ## If we don't have one, _trawler_process should create and 
        ## schedule this one again.
        my $next_trawler = $obj->{Trawlers}->{$network}->[0];
        if (defined $next_trawler) {
          my $next_run_at  = time + ($opts->{interval} || 600);
          $kernel->alarm_add(
            '_trawler_run', $next_run_at, $next_trawler
          );
          log_to('irc', 'info', "Scheduling next trawler for $network");
        }
      } else {
        ## Trawler still pending or running.
        my $servername = $trawler->info->connectedto;
        push(@pending, $servername);
      }
      ++$idx;
    } ## TRAWLER

    log_to('irc', 'debug',
      "Trawlers pending for $network: ". join ', ', @pending
    );

  } ## NETWORK

  $kernel->alarm('_timer_chk' => time + 3);  
}

sub _trawler_run {
  my ($kernel, $heap, $trawler) = @_[KERNEL, HEAP, ARG0];
  unless (blessed $trawler) {
    log_to('irc', 'warn', "_trawler_run received unblessed trawler");
    return
  }
  my $server = $trawler->info->connectedto;
  log_to('irc', 'debug', "Trawler run issued for $server");
  $trawler->run;

  ++$state->{stats}->{TrawlersExecuted};
  $state->{stats}->{LastTrawl} = time;
}

sub create_trawler {
  my %trawlopts = @_;
  my $this_cf = \%trawlopts;
  my $trawler = IRC::Indexer::Trawl::Bot->new(
    Server => $this_cf->{Server},
    Port   => $this_cf->{Port},
    Nickname => $this_cf->{Nickname},
    Timeout  => $this_cf->{Timeout},
    Interval => $this_cf->{Interval},
    BindAddr => $this_cf->{BindAddr},
    UseIPV6  => $this_cf->{UseIPV6},
  );
  
  ++$state->{stats}->{TrawlersCreated};
  
  return $trawler
}

sub _start {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  $kernel->alias_set('indexerhttp');
  
  $kernel->sig('INT', '_sig_int');
  $kernel->sig('TERM', '_sig_int');

  log_to('session', 'info', 'Session started');

  ## init httpd
  my @htstates = poco_cfg_httpd();
  
  ## add states from $state->{htevents}
  $kernel->state($_, __PACKAGE__) for @{$state->{htevents}};
  
  my($total_nets, $total_servers);
  NETWORK: for my $network (keys %{ $cfg->{Networks} }) {
    ++$total_nets;
    my $this_net = $cfg->{Networks}->{$network};
    SERVER: for my $server (keys %$this_net) {
      ++$total_servers;
      my $this_cf = $this_net->{$server};
      
      log_to('irc', 'info', "Init trawler: $network -> $server");

      my %trawlopts = %$this_cf;
      my $trawler = create_trawler(Server => $server, %trawlopts);
      
      ## push to network's trawler array
      push( @{ $obj->{Trawlers}->{$network} }, $trawler);
      
      log_to('irc', 'debug', "Trawler constructed for $server");      
    } ## SERVER
          
    ## add to chk pool
    $state->{timers}->{trawlers}->{$network} = {
      LastRun => 0,
    };

  } ## NETWORK
  
  $kernel->alarm('_timer_chk' => time + 3);

  log_to('irc', 'info',
    "Trawling $total_servers servers across $total_nets networks"
  );

  $state->{stats}->{TotalNetworks} = $total_nets;
  $state->{stats}->{TotalServers}  = $total_servers;
}

sub _sig_int {
  $_[KERNEL]->yield('_stop');
}

sub _stop {
  log_to('session', 'warn', "_stop received");
  unlink($cfg->{CacheDB}) if tied %JSCache;
  undef %JSCache;
  $_[KERNEL]->signal( $_[KERNEL], 'shutdown' );
}

## HTTP states

sub h_error_404 {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp, $reason) = @_[ARG0, ARG1, ARG2];
    
  my $uri  = URI->new( $req->uri );
  my $path = $uri->path;
  my $conn = $req->connection;
  my $addr = $conn->remote_host;
  
  log_to('http', 'info', "$addr 404 $path");
  
  $reason = "Undefined action: ".$req->uri unless $reason;
  $resp->error(404, $reason);
}

sub h_src {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];
  
  unless ($opts->{showsource}) {
    $kernel->yield( h_error_404 => $req, $resp );
    return
  }

  my $src;
  seek(DATA, 0, 0);
  {
    local $/; $src = <DATA>;
  }

  $resp->content_type('text/plain');
  $resp->content($src);
  $resp->respond;

  my $conn = $req->connection;
  my $addr = $conn->remote_host;
  log_to('http', 'info', "$addr 200 h_src");
  
  $resp->done;
}

sub h_stats {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];

  my $uri = URI->new($req->uri);
  my @chunks = $uri->path_segments;
  splice @chunks, 0, 2;

  my ($method) = @chunks;
  $method = 'json' unless $method;
  
  if ($method eq 'text' || $method eq 'plain') {
    my $n_count = $state->{stats}->{TotalNetworks};
    my $s_count = $state->{stats}->{TotalServers};
    $resp->content_type('text/plain');
    $resp->content(
        "Trawling $s_count servers across $n_count networks\n\n"
      . "Version: $IRC::Indexer::VERSION\n\n"
    );
  } else {
    $resp->content_type('application/json');
    my $ref = $state->{stats};
    my $json = JSON::XS->new->utf8(1)->pretty->encode($ref);
    $resp->content($json);
  }

  $resp->respond;

  my $conn = $req->connection;
  my $addr = $conn->remote_host;
  log_to('http', 'info', "$addr 200 h_stats");
  
  $resp->done;
}

sub h_server {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp)       = @_[ARG0, ARG1];
  my ($network, $server) = @_[ARG2, ARG3];
  ## handed off by h_network

  my $json;
  unless ( $json = restore_json($network, $server) ) {
    ## no JSON for this server, 404
    my $reason;
    
    if (defined $cfg->{Networks}->{$network}
        && defined $cfg->{Networks}->{$network}->{$server}
    ) {
      ## configured but not trawled (yet)
      $reason = "$server ($network) configured but no data";
    } else {
      $reason = "No such server";
    }

    $kernel->yield( h_error_404 => $req, $resp, $reason );
    return
  }
  
  $resp->content_type('application/json');
  $resp->content($json);

  $resp->respond;

  my $conn = $req->connection;
  my $addr = $conn->remote_host;
  log_to('http', 'info', "$addr 200 h_server $network $server");
  
  $resp->done;
}

sub h_servlist {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp, $network) = @_[ARG0, ARG1, ARG2];
  ## handed off by h_network

  my $servlist;
  
  if (tied %JSCache) {
    my @cachekeys = grep { /^$network%/ } keys %JSCache;
    map { s/^$network%// } @cachekeys;
    $servlist = [ @cachekeys ];
  } else {
    $servlist = [ keys %{ $jsmemcache->{Servers}->{$network}//{} } ];
  }
  
  my $jsify = IRC::Indexer::Output::JSON->new(
    Input => $servlist,
  );
  my $json = $jsify->dump;
  
  $resp->content_type('application/json');
  $resp->content($json);
  
  $resp->respond;

  my $conn = $req->connection;
  my $addr = $conn->remote_host;
  log_to('http', 'info', "$addr 200 h_servlist $network");
  
  $resp->done;
}

sub h_netlist {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];

  ## Return JSONified array of pullable networks:

  my $netlist;
  
  if (tied %JSCache) {
    $netlist = [ grep { index($_, '%') == -1 } keys %JSCache ];
  } else {
    $netlist = [ keys %{ $jsmemcache->{Networks}//{} } ];
  }

  my $jsify = IRC::Indexer::Output::JSON->new(
    Input => $netlist,
  );
  my $json = $jsify->dump;
  
  $resp->content_type('application/json');
  $resp->content($json);

  $resp->respond;

  my $conn = $req->connection;
  my $addr = $conn->remote_host;
  log_to('http', 'info', "$addr 200 h_netlist");

  $resp->done;
}

sub h_list {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];

  ## Return all configured networks/servers

  my $jsify = IRC::Indexer::Output::JSON->new(
    Input => $cfg->{Networks},
  );
  my $json = $jsify->dump;
  
  $resp->content_type('application/json');
  $resp->content($json);
  
  $resp->respond;

  my $conn = $req->connection;
  my $addr = $conn->remote_host;
  log_to('http', 'info', "$addr 200 h_list");
  
  $resp->done;
}

sub h_network {
  my ($kernel, $heap) = @_[KERNEL, HEAP];
  my ($req, $resp) = @_[ARG0, ARG1];
  ## handler for /network/...

  my $uri = URI->new($req->uri);
  my @chunks = $uri->path_segments;
  splice @chunks, 0, 2;

  my ($network) = @chunks;
  unless ($network) {
    ## supply JSONified network list:
    $kernel->yield( h_netlist => $req, $resp );
    return
  }

  my $json;
  ## We don't know this network:
  unless ( $json = restore_json($network) ) {
    my $reason;
    if (defined $cfg->{Networks}->{$network}) {
      ## configured but not trawled
      $reason = "$network pending trawler run";
    } else {
      $reason = "No such network";
    }
    $kernel->yield( h_error_404 => $req, $resp, $reason );
    return
  }

  ## if this is a /network/<net>/server, hand it off:
  if ($chunks[1] && $chunks[1] eq "server") {
    my $server = $chunks[2];
    unless ($server) {
      ## supply available server list:
      $kernel->yield( h_servlist => $req, $resp, $network );
      return
    }
    $kernel->yield( h_server => $req, $resp, $network, $server );
    return
  }    

  ## otherwise, try to serve a net hash:
  
  $resp->content_type('application/json');
  $resp->content($json);

  $resp->respond;

  my $conn = $req->connection;
  my $addr = $conn->remote_host;
  log_to('http', 'info', "$addr 200 h_network $network");
  $resp->done;
}

sub post_request {
  ++$state->{stats}->{HTTP_Responses};
}


sub start_indexer {
  if ($opts->{detach}) {
    print "Starting detached indexer.\n";
    
    my $fork = fork;
    exit 1 if not defined $fork;
    exit 0 if $fork;
    POSIX::setsid();
    $fork = fork;
    exit 1 if not defined $fork;
    exit 0 if $fork;
    open(STDIN, '<', '/dev/null');
    open(STDOUT, '>>', '/dev/null');
    open(STDERR, '>>', '/dev/null');
    umask(022);
  }

  get_cfg();
  poco_init_session();
  POE::Kernel->run;
}

start_indexer();

__END__

=pod

=head1 NAME

ircindexer-server-json - Serve IRC::Indexer JSON over HTTP

=head1 SYNOPSIS

  ## Create example httpd.cf:
  $ ircindexer-examplecf -t httpd -o httpd.cf
  $ $EDITOR httpd.cf

  ## Add some servers:
  $ mkdir -p networks/cobaltirc
  $ ircindexer-examplecf -t spec -o \
      networks/cobaltirc/phoenix.xyloid.org
  $ $EDITOR networks/cobaltirc/phoenix.xyloid.org

  ## Start server:
  $ ircindexer-server-json -c httpd.cf

=head1 DESCRIPTION

Indexes sets of servers in parallel via L<IRC::Indexer>, exporting 
information as JSON via HTTP for ease of retrieval.

Uses L<POEx::HTTP::Server> to provide HTTP daemon functionality.

See L<IRC::Indexer::POD::ExampleClients> for some examples of ways to 
make use of the exported data on the client side.

=head2 Fetching JSON

Networks or servers that are configured but not yet trawled will report 
a 404 error with a string indicating that the trawl run is pending.

=head3 List

A hash containing networks and servers scheduled for trawling is 
available via B</list>:

  ## JSON hash containing network -> server mapping of
  ## configured trawlers:
  http://my.server:8700/list

Note that this is the list of configured network -> server maps, not 
necessarily the list of B<trawled> servers.

That is to say, the network names are guaranteed valid, but the server 
names may not be available under the /network/<NET>/server/ tree; for a 
list of servers available for retrieval, see L</Servers>, below.

=head3 Networks

Network information hashes are exported via B</network/> routes:

  ## JSON Network Info hash for 'CobaltIRC':
  http://my.server:8700/network/CobaltIRC

  ## JSON array of available trawled networks:
  http://my.server:8700/network

These are indexed by their configured network name.

=head3 Servers

Specific server hashes as described in L<IRC::Indexer::Trawl::Bot> are 
exported via /network/<NETNAME>/server/<SERVERNAME>:

  ## List of trawled servers for this network:
  http://my.server:8700/network/CobaltIRC/server

  ## Trawl results from a single server:
  http://my.server:8700/network/CobaltIRC/server/eris.oppresses.us

Note that servers are not available for retrieval until they are 
trawled; depending on trawl intervals, it may take some time to cycle 
through all listed servers for a network.

Also note that servers are indexed by their reported server name -- not 
necessarily the name specified in their configuration.

=head3 Stats

Stats regarding the running instance are exported via B</stats>:

  http://my.server:8700/stats

=head1 AUTHOR

Jon Portnoy <avenj@cobaltirc.org>

L<http://www.cobaltirc.org>

=cut
